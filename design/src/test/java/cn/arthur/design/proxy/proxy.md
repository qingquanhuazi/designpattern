目标：
 1、掌握代理模式的应用场景和实现原理
 2、了解静态代理和动态代理的区别;
静态代理:硬编码,手动注入,手动拿到目标对象的引用,手动调用目标对象的方法
动态代理:具有更强的拓展性,自动注入,自动生成一个新的类(同一个继承体系),
共同点:拿到代理目标对象的引用，实现功能增强
 3、了解CGLib和JDK Proxy的根本区别
 4、手写实现自定义的动态代理

定义：为其他对象提供一种代理,以控制对这个对象的访问。

代理对象在客户端和目标对象之间起到中介作用

生活中的代理模式：房产中介、快递小哥、黄牛党

三种角色：
 1、Subject(抽象主题角色):它声明了真实主题和代理主题的共同接口,
                   在任何使用真实主题的地方都可用代理主题，客户端通常需要针对抽象主题角色进行编程。
 2、Proxy(代理主题角色):包含了对真实主题的引用,从而可以在任何时候操作真实主题对象;
     在代理主题角色中提供了一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题;
    代理主题角色还可以控制对真实主题的使用,负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束；
   通常，在代理主题角色中客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作,而不仅仅是单纯调用真实主题对象中的操作

 3、RealSubject(真实主题角色):
 定义了代理角色所代表的真实对象,在真实主题角色中实现了真实的业务操作,客户端可以通过代理主题角色间接调用真实主题角色中定义的操作

优点：
    1、代理模式能将代理对象与真实被调用的目标对象分离
    2、一定程度上降低了系统的耦合度,易于拓展
    3、代理可以起到保护目标对象的作用
    4、增强目标对象的职责
缺点：
   1、代理模式会造成系统设计中类的数目增加
   2、在客户端和目标对象之间增加了一个代理对象，请求处理速度变慢
   3、增加了系统的复杂度

适用场景:
保护目标对象,
增强目标对象

    
静态代理：显示声明被代理对象
动态代理：
    jdkProxy:被代理对象需维持对抽象主题的引用，jdk反射才能依据抽象主题来判断实现哪个接口生成代理对象,依赖更强，调用更复杂，
             生成逻辑较为简单，执行效率低，每次都需要用到反射
    CglibProxy:不需要维持对抽象主题的引用,cglib是直接对真实主题继承生成代理对象,底层没有用到反射，
           cglib目标代理类不能有final修饰的方法,忽略final修饰的方法。


spring中的代理选择原则：
1、当bean有实现接口时,spring就会用jdk的动态代理
2、当bean没有实现接口时,spring选择cglib
3、spring可以通过配置强制使用CGLIB,只需在spring的配置文件中加入如下代码
<aop:aspectj-autoproxy proxy-target-class="true"/>

总结：没空需要别人帮你做
目的：增强职责
生活案例：媒婆
源码：ProxyFactoryBean、JdkDynamicAopProxy、CglibAopProxy
